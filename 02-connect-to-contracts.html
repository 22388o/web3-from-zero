<!DOCTYPE html>

<link rel="stylesheet" href="boilerplate/style.css" />
<script type="module" src="boilerplate/editor.js"></script>

<title>Web3 From Zero - Lesson 2</title>
<h1>2. Connecting to Smart Contract</h1>

<p>
  Smart contracts are the main feature that distinguishes Ethereum from Bitcoin. A smart contract is
  a program running on the Ethereum network, and it can access the blockchain data. 
</p>

<p>
  Smart contracts are written in Solidity. Like Java, Solidity gets compiled to a bytecode that runs
  in a virtual machine. In this case, it's called the Ethereum Virtual Machine, or EVM for short.
</p>

<h2>Interacting with Smart Contracts</h2>

<p>To interact with a smart contract form JavaScript, we need three things:</p>

<ol>
  <li>The address that points to the smart contract</li>
  <li>The full or partial Application Binary Interface (ABI) of the contract</li>
  <li>A provider that is connected to the Ethereum network</li>
</ol>

<p>
  In the last lesson we learned, every EOA or smart contract has an address, this is how we know
  where on the blockchain it is stored.
</p>

<pre>
const address = "0x25ed58c027921E14D86380eA2646E3a1B5C55A8b"
</pre>
<br>

<p>
  To figure out what functions a contract has to offer, we need an ABI, a list of function
  signatures of functions we want to call later. The ABI is used by Ethers.js to figure out what
  arguments a function expects and what values it returned when it finished its work.
</p>

<p>
  When using Ethers.js, we can define the ABI as an array of strings, where the strings are Solidity
  function signatures, just like they would be written in the Solidity programming language.
</p>

<p>Here is an example of an ABI for one function:</p>

<pre>
const abi = [
  "function ownerOf(uint256 tokenId) external view returns (address owner)",
]
</pre>
<br>

<p>
  Functions get defined with the <code>function</code> keyword followed by a name and then the
  arguments in paratheses. Solidity is statically typed and doesn't support floating points but 
  integer types of different sizes.
</p>

<p>
  In the example above the function takes one argument of type <code>uint256</code> and it's named
  <code>tokenId</code>.
</p>

<p>
  The <code>external</code> keyword is an access modifier that marks the function as callable from 
  outside of the contract. This is important because we want to do precisely that.
</p>

<p>
  The <code>view</code> keyword is crucial too because it tells the EVM that the function won't
  modify any on-chain state; it will just read it. This enables us to call it without having a
  wallet because the Ethereum gateway we use can simply read all data from its local copy of the 
  blockchain.
</p>
<p>
  The <code>returns</code> keyword tells is what we get back when we call the
  function. In this case, it's the address of the owner of a token.
</p>

<p>
  The next step is to create a new instance of the contract and call the function!
</p>

<p>Try it yourself in the editor!</p>

<code-editor>
const contractAddress = "0x25ed58c027921E14D86380eA2646E3a1B5C55A8b"
const contractAbi = [
  "function ownerOf(uint256 tokenId) external view returns (address owner)"
]
const provider = ethers.getDefaultProvider()
// Write your code here!
<p>
const smartContract = new ethers.Contract(
  contractAddress,
  contractAbi,
  provider,
)
const owner = await smartContract.ownerOf(2)
print(owner)
</p>
</code-editor>
